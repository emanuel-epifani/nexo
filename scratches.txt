

[Opcode: 0x02] [PayloadLen: 15] [KeyLen: 3] [key: "foo"] [value: "bar123456"]
     ↑              ↑                    ↑─────────────────────────────────↑
  già gestito   già gestito                    QUESTO è il payload



TCP Socket
    ↓
[0x02][0x00 0x00 0x00 0x0F][0x00 0x00 0x00 0x03]['f''o''o']['b''a''r']
    ↓
parse_request() ← Layer 1: Framing
    ↓
Request {
    opcode: 0x02,
    payload: [0x00 0x00 0x00 0x03]['f''o''o']['b''a''r']
}
    ↓
Command::from_request() ← Layer 2: Dispatch
    ↓
KvCommand::parse() ← Layer 3: Deserializzazione
    ↓
    ├─ parse_length_prefixed_string() ← Helper (riutilizzabile)
    │      ↓
    │   ("foo", [b'a', b'r'])
    ↓
KvCommand::Set {
    key: "foo",
    value: vec![b'a', b'r'],
    ttl: None
}
    ↓
route() in routing.rs ← Layer 4: Business logic
    ↓
engine.kv.set("foo", b"bar", None)


KV_SET: [key_len][key][value]
Q_PUSH: [queue_len][queue][value]
KV_GET: [key] (tutto il payload)
S_READ: [topic_len][topic][offset:u64]


Ora (5layers)
network.rs
    ↓ parse_request()
protocol.rs (Command enum + tutti i parse)
    ↓ Command::from_request()
routing.rs (pattern match gigante)
    ↓ engine.kv.method()
kv_manager.rs



Dopo (3 layer)
network.rs
    ↓ parse_request() → (opcode, payload)
routing.rs (range-based dispatch)
    ↓ KvCommands::handle()
kv/commands.rs (parse + execute)
    ↓ manager.method()
kv_manager.rs